#! /usr/bin/env perl

# Author:  Iain Bancarz, ib5@sanger.ac.uk
# May 2012

# Read PLINK genotyping data for X chromosome; write text files containing gender information
# Outputs:  illuminus_gender.txt (for Illuminus caller; in old pipeline, prefixed by project name)
#           sample_xhet_gender.txt (general purpose)

use strict;
use warnings;
use File::Temp qw(tempdir);
use FindBin qw($Bin);
use Getopt::Long;
use plink_binary; # in /software/varinf/gftools/lib ; front-end for C library

my $help;
my ($noModel, $plinkPrefix, $illumOutput, $qcOutput, $plotsDir, $tempDir, $verbose);

GetOptions("h|help"              => \$help,
	   "illuminus-output=s"  => \$illumOutput,
	   "qc-output=s"         => \$qcOutput,
	   "plots-dir=s"         => \$plotsDir,
	   "temp-dir=s"          => \$tempDir,
	   "verbose"             => \$verbose
    );

if ($help) {
    print STDERR "Usage: $0 [ output file options ] PLINK_GTFILE
PLINK_GTFILE is the prefix for binary plink files (without .bed, .bim, .fam extension)
Must specify at least one of: --illuminus-output, --qc-output

Options:
--illuminus-output  Path for output to be used by Illuminus caller 
--qc-output         Path for QC output (more detailed than Illuminus output) 
--plots-dir         Directory for plots generated by model (if any)
--help              Print this help text and exit
--verbose           Print status reports to standard output
";
    exit(0);
}

$plinkPrefix = $ARGV[0];
unless ($plinkPrefix) { die "ERROR: Must supply a PLINK filename prefix!"; }
unless ($illumOutput || $qcOutput) { die "ERROR: Must specify at least one of Illuminus or QC output!"; }
if ($tempDir && (not -e $tempDir)) { mkdir($tempDir); }
$plotsDir ||= 0;
$verbose ||= 0; # verbose mode off by default 
run($plinkPrefix, $illumOutput, $qcOutput, $tempDir, $plotsDir, $verbose);

sub countCallsHets {
    # count successful calls, and het calls, for each snp in given plink binary
    my ($pb, $sampleNamesRef, $verbose, $minCR) = @_;
    my @sampleNames = @$sampleNamesRef;
    my %allHets = ();
    my %allCalls = ();
    foreach my $name (@sampleNames) { $allHets{$name} = 0; }
    my $snps = 0;
    my $snp = new plink_binary::snp;
    my $genotypes = new plink_binary::vectorstr;
    my $snpFail = 0;
    while ($pb->next_snp($snp, $genotypes)) {
	# get calls for each SNP; if call rate OK, update het count for each sample
	my $snp_id = $snp->{"name"};
	my $samples = 0;
	my $noCalls = 0;
	my %hets = ();
	my %calls = ();
	for my $i (0..$genotypes->size() - 1) { # calls for each sample on current snp
	    my $call = $genotypes->get($i);
	    $samples++;
	    if ($call =~ /[N]{2}/) { 
		$noCalls++;
	    } else {
		$calls{$sampleNames[$i]} = 1;
		if (substr($call, 0, 1) ne substr($call, 1, 1)) { $hets{$sampleNames[$i]} = 1; }
	    }
	}
	# update global call/het counts
	if (1-($noCalls/$samples) >= $minCR) {
	    foreach my $sample (keys(%calls)) { $allCalls{$sample}++; }
	    foreach my $sample (keys(%hets)) { $allHets{$sample}++; }
	    $snps++;
	    my $cr = 1 - $noCalls/$samples;
	    if ($verbose && $snps % 1000 == 0) { print $snps." ".$cr."\n"; }
	} else {
	    $snpFail++;
	}
    }
    if ($snps==0) { die "ERROR: No valid SNPs found: $!"; } 
    elsif ($verbose) { print "$snps SNPs passed, $snpFail failed\n"; }
    return (\%allCalls, \%allHets, $snps);
}

sub extractChromData {
    # write plink binary data to given directory, for given chromosome only (defaults to X)
    # return plink_binary object for reading data
    my ($plinkPrefix, $outDir, $chrom, $outPrefix, $verbose) = @_;
    $chrom ||= "X";
    $outPrefix ||= "plink_temp_chrom$chrom";
    $verbose ||= 0;
    my $outArg = $outDir."/$outPrefix";
    my $cmd = "/software/bin/plink --bfile $plinkPrefix --chr $chrom --out $outArg --make-bed";
    unless ($verbose) { $cmd .= " > /dev/null"; } # suppress stdout from plink
    system($cmd);
    my $pb = new plink_binary::plink_binary($outArg);
    return $pb;
}

sub findHetRates {
    # find het rates by sample for given plink binary and sample names
    # het rate defined as: successful calls / het calls for each sample, on snps satisfying min call rate
    my ($pb, $sampleNamesRef, $verbose, $minCR) = @_;
    my @sampleNames = @$sampleNamesRef;
    $minCR ||= 0.95;
    my ($allCallsRef, $allHetsRef, $snps) = countCallsHets($pb, $sampleNamesRef, $verbose, $minCR);
    if ($verbose) { print $snps." SNPs found for het rate computation.\n"; }
    my %allCalls = %$allCallsRef;
    my %allHets = %$allHetsRef;
    my %hetRates = ();
    for my $i (0..$#sampleNames) {
	my $name = $sampleNames[$i];
	my $hetRate;
	if ($allCalls{$name} > 0) { $hetRate = $allHets{$name} / $allCalls{$name}; }
	else { $hetRate = 0; }
	$hetRates{$name} = $hetRate;
	if ($verbose && $i % 100 == 0) {print $i." ".$sampleNames[$i]." ".$hetRate."\n"; }
    }
    return %hetRates;
}

sub getSampleNamesGenders {
    # get sample names and genders from given plink binary object
    # (may want to compare inferred and supplied genders)
    my $pb = shift;
    my $verbose = shift;
    my (@sampleNames, @sampleGenders);
    for my $i (0..$pb->{"individuals"}->size() - 1) {
	my $name = $pb->{"individuals"}->get($i)->{"name"};
	my $gender = $pb->{"individuals"}->get($i)->{"sex"};
	push(@sampleNames, $name);
	push(@sampleGenders, $gender);
	if ($verbose && $i % 100 == 0) {print $i." ".$name."\n"; }
    }
    return (\@sampleNames, \@sampleGenders);
}

sub processInputs {
    # read Plink data; write temporary plink files; write text file for input to check_xhet_gender.pl
    my ($plinkPrefix, $tempDir, $verbose) = @_;
    my $pb = extractChromData($plinkPrefix, $tempDir);
    my ($namesRef, $gendersRef) = getSampleNamesGenders($pb, $verbose);
    my %hetRates = findHetRates($pb, $namesRef, $verbose);
    my $tempPath = $tempDir."/sample_xhet_input.txt";
    writeHetRates(\%hetRates, $namesRef, $tempPath);
    return ($tempPath, $namesRef, $gendersRef);
}

sub readModelOutput {
    # read xhet and inferred gender from model results
    my $inDir = shift;
    my $inPath = $inDir."/sample_xhet_gender_model.txt";
    my (@xhets, @genders);
    open IN, "< $inPath" || die "Cannot open input path $inPath: $!";
    while (<IN>) {
	if (/^sample/) { next; } # skip header line
	chomp;
	my ($name, $xhet, $gender) = split;
	push(@xhets, $xhet);
	push(@genders, $gender);
    }
    close IN;
    return (\@xhets, \@genders);
}

sub writeHetRates {
    # write het rates for each sample to a tab-delimited text file; use as input to R scripts
    # could just iterate over keys of %hetRates, but separate @sampleNames list preserves name order
    my %hetRates = %{shift()};
    my @sampleNames = @{shift()};
    my $outPath = shift;
    open OUT, "> $outPath" || die "Cannot open output path $outPath: $!";
    print OUT "sample\txhet\n"; # column headers; must be as expected by check_xhet_gender.R !
    foreach my $name (@sampleNames) {
	my $out = sprintf("%s\t%.6f\n", ($name, $hetRates{$name}));
	#print $out;
	print OUT $out;
    }
    close OUT;
}

sub writeIllumOutput {
    # read output from xhet gender model; write input for Illuminus caller
    # input simply consists of gender codes, one per line
    my ($gendersRef, $outPath) = @_;
    my @genders = @$gendersRef;
    open OUT, "> $outPath" || die "Cannot open output path $outPath: $!";
    foreach my $gender (@genders) { print OUT "$gender\n"; }
    close OUT;
}

sub writeQcOutput {
    # read output from xhet gender model; write file for QC
    # QC file is similar to old sample_cr_het.txt format
    # tab-delimited file with fields: sample name, xhet, inferred gender, supplied gender
    my ($namesRef, $xhetsRef, $modelGendersRef, $gendersRef, $outPath) = @_;
    my @table = ($namesRef, $xhetsRef, $modelGendersRef, $gendersRef);
    my $lastIndex = $#{@$namesRef};
    my @headers = qw(sample xhet inferred supplied);
    open OUT, "> $outPath" || die "Cannot open output path $outPath: $!";
    print OUT join("\t", @headers)."\n";
    for (my $i=0;$i<=$lastIndex;$i++) {
	my @words = ();
	for (my $j=0;$j<@headers;$j++) { push(@words, $table[$j][$i]); }
	print OUT join("\t", @words)."\n";
    }
    close OUT;
}

sub run {
    # 'main' method to run script
    my ($plinkPrefix, $illumOutput, $qcOutput, $tempDir, $plotsDir, $verbose) = @_;
    $tempDir ||= tempdir(CLEANUP => 1); # CLEANUP deletes this tempdir on script exit
    my ($modelInputPath, $namesRef, $gendersRef) = processInputs($plinkPrefix, $tempDir, $verbose);
    my $cmd = "perl $Bin/check_xhet_gender.pl --input=$modelInputPath --output_dir=$tempDir";
    system($cmd);
    # reprocess model output into correct format; copy plots (if any) to given plots directory
    # could modify check_xhet_gender.pl to make this more efficient
    # but, some reading/writing of temp files is practically inevitable for R script
    my ($xhetsRef, $modelGendersRef) = readModelOutput($tempDir);
    if ($illumOutput) { writeIllumOutput($modelGendersRef, $illumOutput); }
    if ($qcOutput) { writeQcOutput($namesRef, $xhetsRef, $modelGendersRef, $gendersRef, $qcOutput); }
    if ($plotsDir) { 
	my @plots = glob($tempDir."/*.png"); # cleaner than doing cp with the shell expansion
	system("cp ".join(' ', $plots)." $plotsDir"); 
    }
}
